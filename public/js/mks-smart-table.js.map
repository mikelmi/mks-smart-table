{"version":3,"sources":["smart-table.js","mks-smart-table.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mks-smart-table.js","sourcesContent":["/** \n* @version 2.1.8\n* @license MIT\n*/\n(function (ng, undefined){\n    'use strict';\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\n    $templateCache.put('template/smart-table/pagination.html',\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"javascript: void(0);\" ng-click=\"selectPage(page)\">{{page}}</a></li>' +\n        '</ul></nav>');\n}]);\n\n\nng.module('smart-table')\n  .constant('stConfig', {\n    pagination: {\n      template: 'template/smart-table/pagination.html',\n      itemsByPage: 10,\n      displayedPages: 5\n    },\n    search: {\n      delay: 400, // ms\n      inputEvent: 'input'\n    },\n    select: {\n      mode: 'single',\n      selectedClass: 'st-selected'\n    },\n    sort: {\n      ascentClass: 'st-sort-ascent',\n      descentClass: 'st-sort-descent',\n      descendingFirst: false,\n      skipNatural: false,\n      delay:300\n    },\n    pipe: {\n      delay: 100 //ms\n    }\n  });\nng.module('smart-table')\n  .controller('stTableController', ['$scope', '$parse', '$filter', '$attrs', function StTableController ($scope, $parse, $filter, $attrs) {\n    var propertyName = $attrs.stTable;\n    var displayGetter = $parse(propertyName);\n    var displaySetter = displayGetter.assign;\n    var safeGetter;\n    var orderBy = $filter('orderBy');\n    var filter = $filter('filter');\n    var safeCopy = copyRefs(displayGetter($scope));\n    var tableState = {\n      sort: {},\n      search: {},\n      pagination: {\n        start: 0,\n        totalItemCount: 0\n      }\n    };\n    var filtered;\n    var pipeAfterSafeCopy = true;\n    var ctrl = this;\n    var lastSelected;\n\n    function copyRefs (src) {\n      return src ? [].concat(src) : [];\n    }\n\n    function updateSafeCopy () {\n      safeCopy = copyRefs(safeGetter($scope));\n      if (pipeAfterSafeCopy === true) {\n        ctrl.pipe();\n      }\n    }\n\n    function deepDelete (object, path) {\n      if (path.indexOf('.') != -1) {\n        var partials = path.split('.');\n        var key = partials.pop();\n        var parentPath = partials.join('.');\n        var parentObject = $parse(parentPath)(object)\n        delete parentObject[key];\n        if (Object.keys(parentObject).length == 0) {\n          deepDelete(object, parentPath);\n        }\n      } else {\n        delete object[path];\n      }\n    }\n\n    if ($attrs.stSafeSrc) {\n      safeGetter = $parse($attrs.stSafeSrc);\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc ? safeSrc.length : 0;\n      }, function (newValue, oldValue) {\n        if (newValue !== safeCopy.length) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        return safeGetter($scope);\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          tableState.pagination.start = 0;\n          updateSafeCopy();\n        }\n      });\n    }\n\n    /**\n     * sort the rows\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\n     * @param [reverse] - if you want to reverse the order\n     */\n    this.sortBy = function sortBy (predicate, reverse) {\n      tableState.sort.predicate = predicate;\n      tableState.sort.reverse = reverse === true;\n\n      if (ng.isFunction(predicate)) {\n        tableState.sort.functionName = predicate.name;\n      } else {\n        delete tableState.sort.functionName;\n      }\n\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * search matching rows\n     * @param {String} input - the input string\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\n     */\n    this.search = function search (input, predicate) {\n      var predicateObject = tableState.search.predicateObject || {};\n      var prop = predicate ? predicate : '$';\n\n      input = ng.isString(input) ? input.trim() : input;\n      $parse(prop).assign(predicateObject, input);\n      // to avoid to filter out null value\n      if (!input) {\n        deepDelete(predicateObject, prop);\n      }\n      tableState.search.predicateObject = predicateObject;\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\n     */\n    this.pipe = function pipe () {\n      var pagination = tableState.pagination;\n      var output;\n      filtered = tableState.search.predicateObject ? filter(safeCopy, tableState.search.predicateObject) : safeCopy;\n      if (tableState.sort.predicate) {\n        filtered = orderBy(filtered, tableState.sort.predicate, tableState.sort.reverse);\n      }\n      pagination.totalItemCount = filtered.length;\n      if (pagination.number !== undefined) {\n        pagination.numberOfPages = filtered.length > 0 ? Math.ceil(filtered.length / pagination.number) : 1;\n        pagination.start = pagination.start >= filtered.length ? (pagination.numberOfPages - 1) * pagination.number : pagination.start;\n        output = filtered.slice(pagination.start, pagination.start + parseInt(pagination.number));\n      }\n      displaySetter($scope, output || filtered);\n    };\n\n    /**\n     * select a dataRow (it will add the attribute isSelected to the row object)\n     * @param {Object} row - the row to select\n     * @param {String} [mode] - \"single\" or \"multiple\" (multiple by default)\n     */\n    this.select = function select (row, mode) {\n      var rows = copyRefs(displayGetter($scope));\n      var index = rows.indexOf(row);\n      if (index !== -1) {\n        if (mode === 'single') {\n          row.isSelected = row.isSelected !== true;\n          if (lastSelected) {\n            lastSelected.isSelected = false;\n          }\n          lastSelected = row.isSelected === true ? row : undefined;\n        } else {\n          rows[index].isSelected = !rows[index].isSelected;\n        }\n      }\n    };\n\n    /**\n     * take a slice of the current sorted/filtered collection (pagination)\n     *\n     * @param {Number} start - start index of the slice\n     * @param {Number} number - the number of item in the slice\n     */\n    this.slice = function splice (start, number) {\n      tableState.pagination.start = start;\n      tableState.pagination.number = number;\n      return this.pipe();\n    };\n\n    /**\n     * return the current state of the table\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\n     */\n    this.tableState = function getTableState () {\n      return tableState;\n    };\n\n    this.getFilteredCollection = function getFilteredCollection () {\n      return filtered || safeCopy;\n    };\n\n    /**\n     * Use a different filter function than the angular FilterFilter\n     * @param filterName the name under which the custom filter is registered\n     */\n    this.setFilterFunction = function setFilterFunction (filterName) {\n      filter = $filter(filterName);\n    };\n\n    /**\n     * Use a different function than the angular orderBy\n     * @param sortFunctionName the name under which the custom order function is registered\n     */\n    this.setSortFunction = function setSortFunction (sortFunctionName) {\n      orderBy = $filter(sortFunctionName);\n    };\n\n    /**\n     * Usually when the safe copy is updated the pipe function is called.\n     * Calling this method will prevent it, which is something required when using a custom pipe function\n     */\n    this.preventPipeOnWatch = function preventPipe () {\n      pipeAfterSafeCopy = false;\n    };\n  }])\n  .directive('stTable', function () {\n    return {\n      restrict: 'A',\n      controller: 'stTableController',\n      link: function (scope, element, attr, ctrl) {\n\n        if (attr.stSetFilter) {\n          ctrl.setFilterFunction(attr.stSetFilter);\n        }\n\n        if (attr.stSetSort) {\n          ctrl.setSortFunction(attr.stSetSort);\n        }\n      }\n    };\n  });\n\nng.module('smart-table')\n  .directive('stSearch', ['stConfig', '$timeout','$parse', function (stConfig, $timeout, $parse) {\n    return {\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n        var tableCtrl = ctrl;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.search.delay;\n        var event = attr.stInputEvent || stConfig.search.inputEvent;\n\n        attr.$observe('stSearch', function (newValue, oldValue) {\n          var input = element[0].value;\n          if (newValue !== oldValue && input) {\n            ctrl.tableState().search = {};\n            tableCtrl.search(input, newValue);\n          }\n        });\n\n        //table state -> view\n        scope.$watch(function () {\n          return ctrl.tableState().search;\n        }, function (newValue, oldValue) {\n          var predicateExpression = attr.stSearch || '$';\n          if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {\n            element[0].value = $parse(predicateExpression)(newValue.predicateObject) || '';\n          }\n        }, true);\n\n        // view -> table state\n        element.bind(event, function (evt) {\n          evt = evt.originalEvent || evt;\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n\n          promise = $timeout(function () {\n            tableCtrl.search(evt.target.value, attr.stSearch || '');\n            promise = null;\n          }, throttle);\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSelectRow', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      scope: {\n        row: '=stSelectRow'\n      },\n      link: function (scope, element, attr, ctrl) {\n        var mode = attr.stSelectMode || stConfig.select.mode;\n        element.bind('click', function () {\n          scope.$apply(function () {\n            ctrl.select(scope.row, mode);\n          });\n        });\n\n        scope.$watch('row.isSelected', function (newValue) {\n          if (newValue === true) {\n            element.addClass(stConfig.select.selectedClass);\n          } else {\n            element.removeClass(stConfig.select.selectedClass);\n          }\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n\n        var predicate = attr.stSort;\n        var getter = $parse(predicate);\n        var index = 0;\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\n        var stateClasses = [classAscent, classDescent];\n        var sortDefault;\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.sort.delay;\n\n        if (attr.stSortDefault) {\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\n        }\n\n        //view --> table state\n        function sort () {\n          if (descendingFirst) {\n            index = index === 0 ? 2 : index - 1;\n          } else {\n            index++;\n          }\n\n          var func;\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\n          if (index % 3 === 0 && !!skipNatural !== true) {\n            //manual reset\n            index = 0;\n            ctrl.tableState().sort = {};\n            ctrl.tableState().pagination.start = 0;\n            func = ctrl.pipe.bind(ctrl);\n          } else {\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\n          }\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n          if (throttle < 0) {\n            func();\n          } else {\n            promise = $timeout(func, throttle);\n          }\n        }\n\n        element.bind('click', function sortClick () {\n          if (predicate) {\n            scope.$apply(sort);\n          }\n        });\n\n        if (sortDefault) {\n          index = sortDefault === 'reverse' ? 1 : 0;\n          sort();\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().sort;\n        }, function (newValue) {\n          if (newValue.predicate !== predicate) {\n            index = 0;\n            element\n              .removeClass(classAscent)\n              .removeClass(classDescent);\n          } else {\n            index = newValue.reverse === true ? 2 : 1;\n            element\n              .removeClass(stateClasses[index % 2])\n              .addClass(stateClasses[index - 1]);\n          }\n        }, true);\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPagination', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'EA',\n      require: '^stTable',\n      scope: {\n        stItemsByPage: '=?',\n        stDisplayedPages: '=?',\n        stPageChange: '&'\n      },\n      templateUrl: function (element, attrs) {\n        if (attrs.stTemplate) {\n          return attrs.stTemplate;\n        }\n        return stConfig.pagination.template;\n      },\n      link: function (scope, element, attrs, ctrl) {\n\n        scope.stItemsByPage = scope.stItemsByPage ? +(scope.stItemsByPage) : stConfig.pagination.itemsByPage;\n        scope.stDisplayedPages = scope.stDisplayedPages ? +(scope.stDisplayedPages) : stConfig.pagination.displayedPages;\n\n        scope.currentPage = 1;\n        scope.pages = [];\n\n        function redraw () {\n          var paginationState = ctrl.tableState().pagination;\n          var start = 1;\n          var end;\n          var i;\n          var prevPage = scope.currentPage;\n          scope.totalItemCount = paginationState.totalItemCount;\n          scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;\n\n          start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));\n          end = start + scope.stDisplayedPages;\n\n          if (end > paginationState.numberOfPages) {\n            end = paginationState.numberOfPages + 1;\n            start = Math.max(1, end - scope.stDisplayedPages);\n          }\n\n          scope.pages = [];\n          scope.numPages = paginationState.numberOfPages;\n\n          for (i = start; i < end; i++) {\n            scope.pages.push(i);\n          }\n\n          if (prevPage !== scope.currentPage) {\n            scope.stPageChange({newPage: scope.currentPage});\n          }\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().pagination;\n        }, redraw, true);\n\n        //scope --> table state  (--> view)\n        scope.$watch('stItemsByPage', function (newValue, oldValue) {\n          if (newValue !== oldValue) {\n            scope.selectPage(1);\n          }\n        });\n\n        scope.$watch('stDisplayedPages', redraw);\n\n        //view -> table state\n        scope.selectPage = function (page) {\n          if (page > 0 && page <= scope.numPages) {\n            ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);\n          }\n        };\n\n        if (!ctrl.tableState().pagination.number) {\n          ctrl.slice(0, scope.stItemsByPage);\n        }\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPipe', ['stConfig', '$timeout', function (config, $timeout) {\n    return {\n      require: 'stTable',\n      scope: {\n        stPipe: '='\n      },\n      link: {\n\n        pre: function (scope, element, attrs, ctrl) {\n\n          var pipePromise = null;\n\n          if (ng.isFunction(scope.stPipe)) {\n            ctrl.preventPipeOnWatch();\n            ctrl.pipe = function () {\n\n              if (pipePromise !== null) {\n                $timeout.cancel(pipePromise)\n              }\n\n              pipePromise = $timeout(function () {\n                scope.stPipe(ctrl.tableState(), ctrl);\n              }, config.pipe.delay);\n\n              return pipePromise;\n            }\n          }\n        },\n\n        post: function (scope, element, attrs, ctrl) {\n          ctrl.pipe();\n        }\n      }\n    };\n  }]);\n\n})(angular);","(function(){\n\n    var app = angular.module('mks-smart-table', ['smart-table']);\n\n    app.run(['$templateCache',\n        function ($templateCache) {\n            $templateCache.put('template/smart-table/pagination.html',\n                '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\n                '<li><a href=\"javascript: void(0);\" ng-click=\"selectPage(1)\"><span>&laquo;</span></a></li>' +\n                '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"javascript: void(0);\" ng-click=\"selectPage(page)\">{{page}}</a></li>' +\n                '<li><a href=\"javascript: void(0);\" ng-click=\"selectPage(numPages)\"><span>&raquo;</span></a></li>' +\n                '</ul></nav>');\n        }\n    ]);\n\n    app.controller('TableCtrl', ['$http', '$q', '$scope', '$filter',\n        function($http, $q, $scope, $filter) {\n\n            this.rows = [];\n            this.url = null;\n            this.start = 0;\n            this.end = 0;\n            this.total = 0;\n            this.hasSelected = 0;\n            this.idKey = 'id';\n\n            var self = this;\n\n            var canceler = null;\n\n            this.init = function(url, idKey) {\n                this.url = url;\n                if (idKey) {\n                    this.idKey = idKey;\n                }\n            };\n\n            function getPage(url, start, number, params) {\n                if (canceler) {\n                    canceler.resolve('cancel');\n                }\n                canceler = $q.defer();\n\n                var data = {\n                    start: start,\n                    number: number\n                };\n\n                if (params.sort) {\n                    data.sort = params.sort;\n                }\n\n                if (params.search && params.search.predicateObject) {\n                    data.search = params.search.predicateObject;\n                }\n\n                var req = {\n                    'method': 'GET',\n                    'url': url + '?' + jQuery.param(data),\n                    'headers': {\n                        'X-Requested-With': 'XMLHttpRequest'\n                    },\n                    'timeout': canceler.promise\n                };\n                return $http(req);\n            }\n\n            this.pipeServer = function(tableState) {\n                if (!self.url) {\n                    return;\n                }\n\n                self.isLoading = true;\n\n                var pagination = tableState.pagination;\n\n                var start = pagination.start || 0;\n                var number = pagination.number || 10;\n\n                getPage(self.url, start, number, tableState).success(function(result) {\n                    self.rows = result.data;\n                    tableState.pagination.numberOfPages = result.pages;\n\n                    var start = tableState.pagination.start;\n\n                    self.end = start + self.rows.length;\n\n                    if (self.rows.length > 0) {\n                        start++;\n                    }\n\n                    self.start = start;\n                    self.total = result.total;\n                    self.hasSelected = 0;\n                    self.isLoading = false;\n                }).error(function() {\n                    self.isLoading = false;\n                });\n            };\n\n            function removeLocalRow(row) {\n                var index = self.rows.indexOf(row);\n                if (index !== -1) {\n                    self.rows.splice(index, 1);\n                    if (self.total > 0) {\n                        self.total--;\n                    }\n                    if (row.isSelected && self.hasSelected > 0) {\n                        self.hasSelected--;\n                    }\n                }\n            }\n\n            this.removeRow = function(row, url, confirmText) {\n                if (confirmText && !confirm(confirmText)) {\n                    return false;\n                }\n\n                if (!url) {\n                    removeLocalRow(row);\n                    return false;\n                }\n\n                row.isLoading = true;\n                $http.post(url).then(function(){\n                    row.isLoading = false;\n                    removeLocalRow(row);\n                }, function() {\n                    row.isLoading = false;\n                });\n\n                return false;\n            };\n\n            this.getSelected = function() {\n                return $filter('filter')(this.rows, {isSelected: true});\n            };\n\n            function rowIdentities(arr) {\n                return jQuery.map(arr, function(val) {\n                    return val[self.idKey];\n                });\n            }\n\n            this.removeSelected = function(url, confirmText) {\n                if (confirmText && !confirm(confirmText)) {\n                    return false;\n                }\n\n                var selected = this.getSelected();\n\n                if (!selected.length) {\n                    return false;\n                }\n\n                if (!url) {\n                    angular.forEach(selected, function(row) {\n                        removeLocalRow(row);\n                    });\n                    return false;\n                }\n\n                self.isLoading = true;\n                $http.post(url, {id: rowIdentities(selected)}).then(function(){\n                    angular.forEach(selected, function(row) {\n                        removeLocalRow(row);\n                    });\n                    self.isLoading = false;\n                }, function() {\n                    self.isLoading = false;\n                });\n            };\n\n            $scope.$on('row-selected', function(e, selected) {\n                if (selected) {\n                    self.hasSelected++;\n                } else if(self.hasSelected > 0) {\n                    self.hasSelected--;\n                }\n            });\n\n            this.updateRow = function(row, url, confirmText) {\n                if (confirmText && !confirm(confirmText)) {\n                    return false;\n                }\n\n                row.isLoading = true;\n                $http.post(url).then(function(data){\n                    row.isLoading = false;\n                    if (data && data.model) {\n                        angular.extend(row, data.model);\n                    }\n                }, function() {\n                    row.isLoading = false;\n                });\n\n                return false;\n            };\n\n            this.updateSelected = function(url, confirmText) {\n                if (confirmText && !confirm(confirmText)) {\n                    return false;\n                }\n\n                var selected = this.getSelected();\n\n                if (!selected.length) {\n                    return false;\n                }\n\n                self.isLoading = true;\n\n                $http.post(url, {id: rowIdentities(selected)}).then(function(data){\n                    if (data && data.models) {\n                        angular.forEach(selected, function (row) {\n                            if (typeof data.models[row[self.idKey]] != 'undefined') {\n                                angular.extend(row, data.models[row[self.idKey]]);\n                            }\n                        });\n                    }\n                    self.isLoading = false;\n                }, function() {\n                    self.isLoading = false;\n                });\n            };\n        }\n    ]);\n\n    // smart-table external search\n    adminDirectives.directive('stWatchQuery', [function() {\n        return {\n            restrict: 'A',\n            require:'^stTable',\n            scope:{\n                mkWatchQuery:'='\n            },\n            'link': function(scope, el, attr, ctrl) {\n                scope.$watch('stWatchQuery',function(val){\n                    ctrl.search(val);\n                });\n            }\n        }\n    }]);\n\n    // smart-table checkbox for selecting row\n    adminDirectives.directive('stSelectRow', [function() {\n        return {\n            restrict: 'EA',\n            template: '<span class=\"text-muted glyphicon glyphicon-unchecked st-chk\"></span>',\n            scope: {\n                row: '=stSelectRow'\n            },\n            link: function (scope, element) {\n\n                if (scope.row.non_selectable) {\n                    return false;\n                }\n\n                element.on('click', function (evt) {\n                    evt.preventDefault();\n                    scope.$apply(function () {\n                        scope.row.isSelected = !(scope.row.isSelected||0);\n                    });\n                });\n\n                scope.$watch('row.isSelected', function (newValue, oldValue) {\n                    element.parent().toggleClass('st-selected info', newValue == true);\n                    element.children().toggleClass('text-muted glyphicon-unchecked', newValue !== true)\n                        .toggleClass('glyphicon-check', newValue == true);\n\n                    scope.$emit('row-selected', newValue);\n                });\n            }\n        }\n    }]);\n\n// smart-table checkbox for selecting all rows\n    adminDirectives.directive('stSelectAllRows', [function() {\n        return {\n            restrict: 'EA',\n            template: '<span class=\"text-muted glyphicon glyphicon-unchecked st-chk\"></span>',\n            scope: {\n                all: '=stSelectAllRows'\n            },\n            link: function (scope, element) {\n                element.on('click', function (evt) {\n                    evt.preventDefault();\n                    scope.$apply(function () {\n                        scope.isAllSelected = !scope.isAllSelected||false;\n                    });\n                });\n\n                scope.$watch('isAllSelected', function () {\n                    if (!scope.all) {\n                        return;\n                    }\n                    scope.all.forEach(function (val) {\n                        if (!val.non_selectable) {\n                            val.isSelected = scope.isAllSelected || false;\n                        }\n                    });\n\n                    element.children().toggleClass('text-muted glyphicon-unchecked', scope.isAllSelected !== true)\n                        .toggleClass('glyphicon-check', scope.isAllSelected == true);\n                });\n\n                scope.$watch('all', function (newVal, oldVal) {\n                    scope.isAllSelected = false;\n                });\n            }\n        }\n    }]);\n\n})(window.angular);\n"],"sourceRoot":"/source/"}